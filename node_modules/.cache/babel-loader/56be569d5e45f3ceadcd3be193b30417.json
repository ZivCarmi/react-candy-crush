{"ast":null,"code":"import $45QHv$babelruntimehelpersesmextends from \"@babel/runtime/helpers/esm/extends\";\nimport { forwardRef as $45QHv$forwardRef, useState as $45QHv$useState, useRef as $45QHv$useRef, useEffect as $45QHv$useEffect, useCallback as $45QHv$useCallback, createElement as $45QHv$createElement } from \"react\";\nimport { useComposedRefs as $45QHv$useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { Primitive as $45QHv$Primitive } from \"@radix-ui/react-primitive\";\nimport { useCallbackRef as $45QHv$useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nconst $d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT = 'focusScope.autoFocusOnMount';\nconst $d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT = 'focusScope.autoFocusOnUnmount';\nconst $d3863c46a17e8a28$var$EVENT_OPTIONS = {\n  bubbles: false,\n  cancelable: true\n};\n/* -------------------------------------------------------------------------------------------------\n * FocusScope\n * -----------------------------------------------------------------------------------------------*/\nconst $d3863c46a17e8a28$var$FOCUS_SCOPE_NAME = 'FocusScope';\nconst $d3863c46a17e8a28$export$20e40289641fbbb6 = /*#__PURE__*/$45QHv$forwardRef((props, forwardedRef) => {\n  const {\n    loop = false,\n    trapped = false,\n    onMountAutoFocus: onMountAutoFocusProp,\n    onUnmountAutoFocus: onUnmountAutoFocusProp,\n    ...scopeProps\n  } = props;\n  const [container1, setContainer] = $45QHv$useState(null);\n  const onMountAutoFocus = $45QHv$useCallbackRef(onMountAutoFocusProp);\n  const onUnmountAutoFocus = $45QHv$useCallbackRef(onUnmountAutoFocusProp);\n  const lastFocusedElementRef = $45QHv$useRef(null);\n  const composedRefs = $45QHv$useComposedRefs(forwardedRef, node => setContainer(node));\n  const focusScope = $45QHv$useRef({\n    paused: false,\n    pause() {\n      this.paused = true;\n    },\n    resume() {\n      this.paused = false;\n    }\n  }).current; // Takes care of trapping focus if focus is moved outside programmatically for example\n  $45QHv$useEffect(() => {\n    if (trapped) {\n      function handleFocusIn(event) {\n        if (focusScope.paused || !container1) return;\n        const target = event.target;\n        if (container1.contains(target)) lastFocusedElementRef.current = target;else $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {\n          select: true\n        });\n      }\n      function handleFocusOut(event) {\n        if (focusScope.paused || !container1) return;\n        const relatedTarget = event.relatedTarget; // A `focusout` event with a `null` `relatedTarget` will happen in at least two cases:\n        //\n        // 1. When the user switches app/tabs/windows/the browser itself loses focus.\n        // 2. In Google Chrome, when the focused element is removed from the DOM.\n        //\n        // We let the browser do its thing here because:\n        //\n        // 1. The browser already keeps a memory of what's focused for when the page gets refocused.\n        // 2. In Google Chrome, if we try to focus the deleted focused element (as per below), it\n        //    throws the CPU to 100%, so we avoid doing anything for this reason here too.\n        if (relatedTarget === null) return; // If the focus has moved to an actual legitimate element (`relatedTarget !== null`)\n        // that is outside the container, we move focus to the last valid focused element inside.\n        if (!container1.contains(relatedTarget)) $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {\n          select: true\n        });\n      } // When the focused element gets removed from the DOM, browsers move focus\n      // back to the document.body. In this case, we move focus to the container\n      // to keep focus trapped correctly.\n      function handleMutations(mutations) {\n        const focusedElement = document.activeElement;\n        if (focusedElement !== document.body) return;\n        for (const mutation of mutations) if (mutation.removedNodes.length > 0) $d3863c46a17e8a28$var$focus(container1);\n      }\n      document.addEventListener('focusin', handleFocusIn);\n      document.addEventListener('focusout', handleFocusOut);\n      const mutationObserver = new MutationObserver(handleMutations);\n      if (container1) mutationObserver.observe(container1, {\n        childList: true,\n        subtree: true\n      });\n      return () => {\n        document.removeEventListener('focusin', handleFocusIn);\n        document.removeEventListener('focusout', handleFocusOut);\n        mutationObserver.disconnect();\n      };\n    }\n  }, [trapped, container1, focusScope.paused]);\n  $45QHv$useEffect(() => {\n    if (container1) {\n      $d3863c46a17e8a28$var$focusScopesStack.add(focusScope);\n      const previouslyFocusedElement = document.activeElement;\n      const hasFocusedCandidate = container1.contains(previouslyFocusedElement);\n      if (!hasFocusedCandidate) {\n        const mountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);\n        container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container1.dispatchEvent(mountEvent);\n        if (!mountEvent.defaultPrevented) {\n          $d3863c46a17e8a28$var$focusFirst($d3863c46a17e8a28$var$removeLinks($d3863c46a17e8a28$var$getTabbableCandidates(container1)), {\n            select: true\n          });\n          if (document.activeElement === previouslyFocusedElement) $d3863c46a17e8a28$var$focus(container1);\n        }\n      }\n      return () => {\n        container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus); // We hit a react bug (fixed in v17) with focusing in unmount.\n        // We need to delay the focus a little to get around it for now.\n        // See: https://github.com/facebook/react/issues/17894\n        setTimeout(() => {\n          const unmountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);\n          container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          container1.dispatchEvent(unmountEvent);\n          if (!unmountEvent.defaultPrevented) $d3863c46a17e8a28$var$focus(previouslyFocusedElement !== null && previouslyFocusedElement !== void 0 ? previouslyFocusedElement : document.body, {\n            select: true\n          });\n          // we need to remove the listener after we `dispatchEvent`\n          container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          $d3863c46a17e8a28$var$focusScopesStack.remove(focusScope);\n        }, 0);\n      };\n    }\n  }, [container1, onMountAutoFocus, onUnmountAutoFocus, focusScope]); // Takes care of looping focus (when tabbing whilst at the edges)\n  const handleKeyDown = $45QHv$useCallback(event => {\n    if (!loop && !trapped) return;\n    if (focusScope.paused) return;\n    const isTabKey = event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey;\n    const focusedElement = document.activeElement;\n    if (isTabKey && focusedElement) {\n      const container = event.currentTarget;\n      const [first, last] = $d3863c46a17e8a28$var$getTabbableEdges(container);\n      const hasTabbableElementsInside = first && last; // we can only wrap focus if we have tabbable edges\n      if (!hasTabbableElementsInside) {\n        if (focusedElement === container) event.preventDefault();\n      } else {\n        if (!event.shiftKey && focusedElement === last) {\n          event.preventDefault();\n          if (loop) $d3863c46a17e8a28$var$focus(first, {\n            select: true\n          });\n        } else if (event.shiftKey && focusedElement === first) {\n          event.preventDefault();\n          if (loop) $d3863c46a17e8a28$var$focus(last, {\n            select: true\n          });\n        }\n      }\n    }\n  }, [loop, trapped, focusScope.paused]);\n  return /*#__PURE__*/$45QHv$createElement($45QHv$Primitive.div, $45QHv$babelruntimehelpersesmextends({\n    tabIndex: -1\n  }, scopeProps, {\n    ref: composedRefs,\n    onKeyDown: handleKeyDown\n  }));\n});\n/*#__PURE__*/\nObject.assign($d3863c46a17e8a28$export$20e40289641fbbb6, {\n  displayName: $d3863c46a17e8a28$var$FOCUS_SCOPE_NAME\n});\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/ /**\n                                                                                                     * Attempts focusing the first element in a list of candidates.\n                                                                                                     * Stops when focus has actually moved.\n                                                                                                     */\nfunction $d3863c46a17e8a28$var$focusFirst(candidates) {\n  let {\n    select = false\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const previouslyFocusedElement = document.activeElement;\n  for (const candidate of candidates) {\n    $d3863c46a17e8a28$var$focus(candidate, {\n      select: select\n    });\n    if (document.activeElement !== previouslyFocusedElement) return;\n  }\n}\n/**\n * Returns the first and last tabbable elements inside a container.\n */\nfunction $d3863c46a17e8a28$var$getTabbableEdges(container) {\n  const candidates = $d3863c46a17e8a28$var$getTabbableCandidates(container);\n  const first = $d3863c46a17e8a28$var$findVisible(candidates, container);\n  const last = $d3863c46a17e8a28$var$findVisible(candidates.reverse(), container);\n  return [first, last];\n}\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction $d3863c46a17e8a28$var$getTabbableCandidates(container) {\n  const nodes = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: node => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP; // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode); // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n/**\n * Returns the first visible element in a list.\n * NOTE: Only checks visibility up to the `container`.\n */\nfunction $d3863c46a17e8a28$var$findVisible(elements, container) {\n  for (const element of elements) {\n    // we stop checking if it's hidden at the `container` level (excluding)\n    if (!$d3863c46a17e8a28$var$isHidden(element, {\n      upTo: container\n    })) return element;\n  }\n}\nfunction $d3863c46a17e8a28$var$isHidden(node, _ref) {\n  let {\n    upTo: upTo\n  } = _ref;\n  if (getComputedStyle(node).visibility === 'hidden') return true;\n  while (node) {\n    // we stop at `upTo` (excluding it)\n    if (upTo !== undefined && node === upTo) return false;\n    if (getComputedStyle(node).display === 'none') return true;\n    node = node.parentElement;\n  }\n  return false;\n}\nfunction $d3863c46a17e8a28$var$isSelectableInput(element) {\n  return element instanceof HTMLInputElement && 'select' in element;\n}\nfunction $d3863c46a17e8a28$var$focus(element) {\n  let {\n    select = false\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  // only focus if that element is focusable\n  if (element && element.focus) {\n    const previouslyFocusedElement = document.activeElement; // NOTE: we prevent scrolling on focus, to minimize jarring transitions for users\n    element.focus({\n      preventScroll: true\n    }); // only select if its not the same element, it supports selection and we need to select\n    if (element !== previouslyFocusedElement && $d3863c46a17e8a28$var$isSelectableInput(element) && select) element.select();\n  }\n}\n/* -------------------------------------------------------------------------------------------------\n * FocusScope stack\n * -----------------------------------------------------------------------------------------------*/\nconst $d3863c46a17e8a28$var$focusScopesStack = $d3863c46a17e8a28$var$createFocusScopesStack();\nfunction $d3863c46a17e8a28$var$createFocusScopesStack() {\n  /** A stack of focus scopes, with the active one at the top */let stack = [];\n  return {\n    add(focusScope) {\n      // pause the currently active focus scope (at the top of the stack)\n      const activeFocusScope = stack[0];\n      if (focusScope !== activeFocusScope) activeFocusScope === null || activeFocusScope === void 0 || activeFocusScope.pause();\n      // remove in case it already exists (because we'll re-add it at the top of the stack)\n      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n    remove(focusScope) {\n      var _stack$;\n      stack = $d3863c46a17e8a28$var$arrayRemove(stack, focusScope);\n      (_stack$ = stack[0]) === null || _stack$ === void 0 || _stack$.resume();\n    }\n  };\n}\nfunction $d3863c46a17e8a28$var$arrayRemove(array, item) {\n  const updatedArray = [...array];\n  const index = updatedArray.indexOf(item);\n  if (index !== -1) updatedArray.splice(index, 1);\n  return updatedArray;\n}\nfunction $d3863c46a17e8a28$var$removeLinks(items) {\n  return items.filter(item => item.tagName !== 'A');\n}\nconst $d3863c46a17e8a28$export$be92b6f5f03c0fe9 = $d3863c46a17e8a28$export$20e40289641fbbb6;\nexport { $d3863c46a17e8a28$export$20e40289641fbbb6 as FocusScope, $d3863c46a17e8a28$export$be92b6f5f03c0fe9 as Root };","map":{"version":3,"sources":["C:\\Users\\Ziv\\Desktop\\Work\\ziv-react-candy-crush\\node_modules\\@radix-ui\\react-focus-scope\\dist\\packages\\react\\focus-scope\\src\\FocusScope.tsx"],"names":["AUTOFOCUS_ON_MOUNT","AUTOFOCUS_ON_UNMOUNT","EVENT_OPTIONS","bubbles","cancelable","FOCUS_SCOPE_NAME","FocusScope","props","forwardedRef","loop","trapped","onMountAutoFocus","onMountAutoFocusProp","onUnmountAutoFocus","onUnmountAutoFocusProp","container","setContainer","React","useCallbackRef","lastFocusedElementRef","composedRefs","useComposedRefs","node","focusScope","paused","pause","resume","current","handleFocusIn","event","target","contains","select","handleFocusOut","relatedTarget","handleMutations","mutations","focusedElement","document","activeElement","body","mutation","removedNodes","length","focus","addEventListener","mutationObserver","MutationObserver","observe","childList","subtree","removeEventListener","disconnect","focusScopesStack","add","previouslyFocusedElement","hasFocusedCandidate","mountEvent","CustomEvent","dispatchEvent","defaultPrevented","focusFirst","removeLinks","getTabbableCandidates","setTimeout","unmountEvent","remove","handleKeyDown","isTabKey","key","altKey","ctrlKey","metaKey","currentTarget","first","last","getTabbableEdges","hasTabbableElementsInside","preventDefault","shiftKey","scopeProps","candidates","candidate","findVisible","reverse","nodes","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","isHiddenInput","tagName","type","disabled","hidden","FILTER_SKIP","tabIndex","FILTER_ACCEPT","nextNode","push","currentNode","elements","element","isHidden","upTo","getComputedStyle","visibility","undefined","display","parentElement","isSelectableInput","HTMLInputElement","preventScroll","createFocusScopesStack","stack","activeFocusScope","arrayRemove","unshift","array","item","updatedArray","index","indexOf","splice","items","filter","Root"],"mappings":";;;;;AAOA,MAAMA,wCAAkB,GAAG,6BAA3B;AACA,MAAMC,0CAAoB,GAAG,+BAA7B;AACA,MAAMC,mCAAa,GAAG;EAAEC,OAAO,EAAE,KAAX;EAAkBC,UAAU,EAAVA;CAAlB;AAItB;;AAEA;AAEA,MAAMC,sCAAgB,GAAG,YAAzB;AAgCA,MAAMC,yCAAU,GAAA,aAAG,iBAAA,CAAqD,CAACC,KAAD,EAAQC,YAAR,KAAyB;EAC/F,MAAM;IACJC,IAAI,GAAG,KADH;IAEJC,OAAO,GAAG,KAFN;IAGJC,gBAAgB,EAAEC,oBAHd;IAIJC,kBAAkB,EAAEC,sBAJhB;IAKJ,GAAA;EAAA,CALI,GAMFP,KANE;EAON,MAAM,CAACQ,UAAD,EAAYC,YAAZ,CAAA,GAA4BC,eAAAA,CAAmC,IAAnCA,CAAlC;EACA,MAAMN,gBAAgB,GAAGO,qBAAc,CAACN,oBAAD,CAAvC;EACA,MAAMC,kBAAkB,GAAGK,qBAAc,CAACJ,sBAAD,CAAzC;EACA,MAAMK,qBAAqB,GAAGF,aAAAA,CAAiC,IAAjCA,CAA9B;EACA,MAAMG,YAAY,GAAGC,sBAAe,CAACb,YAAD,EAAgBc,IAAD,IAAUN,YAAY,CAACM,IAAtC,CAAA,CAApC;EAEA,MAAMC,UAAU,GAAG,aAAA,CAAa;IAC9BC,MAAM,EAAE,KADsB;IAE9BC,KAAK,CAAA,EAAG;MACN,IAAA,CAAKD,MAAL,GAAc,IAAd;KAH4B;IAK9BE,MAAM,CAAA,EAAG;MACP,IAAA,CAAKF,MAAL,GAAc,KAAd;IACD;GAPgB,CAAA,CAQhBG,OARH,CAAA,CAAgC;EAWhCV,gBAAAA,CAAgB,MAAM;IACpB,IAAIP,OAAJ,EAAa;MACX,SAASkB,aAAT,CAAuBC,KAAvB,EAA0C;QACxC,IAAIN,UAAU,CAACC,MAAXD,IAAqB,CAACR,UAA1B,EAAA;QACA,MAAMe,MAAM,GAAGD,KAAK,CAACC,MAArB;QACA,IAAIf,UAAS,CAACgB,QAAVhB,CAAmBe,MAAnBf,CAAJ,EACEI,qBAAqB,CAACQ,OAAtBR,GAAgCW,MAAhCX,CAAAA,KAEA,2BAAK,CAACA,qBAAqB,CAACQ,OAAvB,EAAgC;UAAEK,MAAM,EAANA;SAAlC,CAAL;MAEH;MAED,SAASC,cAAT,CAAwBJ,KAAxB,EAA2C;QACzC,IAAIN,UAAU,CAACC,MAAXD,IAAqB,CAACR,UAA1B,EAAA;QACA,MAAMmB,aAAa,GAAGL,KAAK,CAACK,aAA5B,CAAA,CAAA;QAGA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,IAAIA,aAAa,KAAK,IAAtB,EAA4B,OAda,CAczC;QAGA;QACA,IAAI,CAACnB,UAAS,CAACgB,QAAVhB,CAAmBmB,aAAnBnB,CAAL,EACE,2BAAK,CAACI,qBAAqB,CAACQ,OAAvB,EAAgC;UAAEK,MAAM,EAANA;SAAlC,CAAL;OA9BO,CAgCV;MAGD;MACA;MACA,SAASG,eAAT,CAAyBC,SAAzB,EAAsD;QACpD,MAAMC,cAAc,GAAGC,QAAQ,CAACC,aAAhC;QACA,IAAIF,cAAc,KAAKC,QAAQ,CAACE,IAAhC,EAAA;QACA,KAAK,MAAMC,QAAX,IAAuBL,SAAvB,EACE,IAAIK,QAAQ,CAACC,YAATD,CAAsBE,MAAtBF,GAA+B,CAAnC,EAAsCG,2BAAK,CAAC7B,UAAD,CAA3C;MAEH;MAEDuB,QAAQ,CAACO,gBAATP,CAA0B,SAA1BA,EAAqCV,aAArCU,CAAAA;MACAA,QAAQ,CAACO,gBAATP,CAA0B,UAA1BA,EAAsCL,cAAtCK,CAAAA;MACA,MAAMQ,gBAAgB,GAAG,IAAIC,gBAAJ,CAAqBZ,eAArB,CAAzB;MACA,IAAIpB,UAAJ,EAAe,gBAAgB,CAACiC,OAAjB,CAAyBjC,UAAzB,EAAoC;QAAEkC,SAAS,EAAE,IAAb;QAAmBC,OAAO,EAAPA;OAAvD,CAAoC;MAEnD,OAAO,MAAM;QACXZ,QAAQ,CAACa,mBAATb,CAA6B,SAA7BA,EAAwCV,aAAxCU,CAAAA;QACAA,QAAQ,CAACa,mBAATb,CAA6B,UAA7BA,EAAyCL,cAAzCK,CAAAA;QACAQ,gBAAgB,CAACM,UAAjBN,CAAAA,CAAAA;OAHF;IAKD;GAxDH7B,EAyDG,CAACP,OAAD,EAAUK,UAAV,EAAqBQ,UAAU,CAACC,MAAhC,CAzDHP,CAyDC;EAEDA,gBAAAA,CAAgB,MAAM;IACpB,IAAIF,UAAJ,EAAe;MACbsC,sCAAgB,CAACC,GAAjBD,CAAqB9B,UAArB8B,CAAAA;MACA,MAAME,wBAAwB,GAAGjB,QAAQ,CAACC,aAA1C;MACA,MAAMiB,mBAAmB,GAAGzC,UAAS,CAACgB,QAAVhB,CAAmBwC,wBAAnBxC,CAA5B;MAEA,IAAI,CAACyC,mBAAL,EAA0B;QACxB,MAAMC,UAAU,GAAG,IAAIC,WAAJ,CAAgB1D,wCAAhB,EAAoCE,mCAApC,CAAnB;QACAa,UAAS,CAAC8B,gBAAV9B,CAA2Bf,wCAA3Be,EAA+CJ,gBAA/CI,CAAAA;QACAA,UAAS,CAAC4C,aAAV5C,CAAwB0C,UAAxB1C,CAAAA;QACA,IAAI,CAAC0C,UAAU,CAACG,gBAAhB,EAAkC;UAChCC,gCAAU,CAACC,iCAAW,CAACC,2CAAqB,CAAChD,UAAD,CAAtB,CAAZ,EAAgD;YAAEiB,MAAM,EAANA;WAAlD,CAAV6B;UACA,IAAIvB,QAAQ,CAACC,aAATD,KAA2BiB,wBAA/B,EACEX,2BAAK,CAAC7B,UAAD,CAAL6B;QAEH;MACF;MAED,OAAO,MAAM;QACX7B,UAAS,CAACoC,mBAAVpC,CAA8Bf,wCAA9Be,EAAkDJ,gBAAlDI,CAAAA,CADW,CACXA;QAGA;QACA;QACAiD,UAAU,CAAC,MAAM;UACf,MAAMC,YAAY,GAAG,IAAIP,WAAJ,CAAgBzD,0CAAhB,EAAsCC,mCAAtC,CAArB;UACAa,UAAS,CAAC8B,gBAAV9B,CAA2Bd,0CAA3Bc,EAAiDF,kBAAjDE,CAAAA;UACAA,UAAS,CAAC4C,aAAV5C,CAAwBkD,YAAxBlD,CAAAA;UACA,IAAI,CAACkD,YAAY,CAACL,gBAAlB,EACE,2BAAK,CAACL,wBAAD,KAAA,IAAA,IAACA,wBAAD,KAAA,KAAA,CAAA,GAACA,wBAAD,GAA6BjB,QAAQ,CAACE,IAAtC,EAA4C;YAAER,MAAM,EAANA;WAA9C,CAAL;UACD;UAEDjB,UAAS,CAACoC,mBAAVpC,CAA8Bd,0CAA9Bc,EAAoDF,kBAApDE,CAAAA;UAEAsC,sCAAgB,CAACa,MAAjBb,CAAwB9B,UAAxB8B,CAAAA;SAVQ,EAWP,CAXO,CAAVW;OANF;IAmBD;GArCH/C,EAsCG,CAACF,UAAD,EAAYJ,gBAAZ,EAA8BE,kBAA9B,EAAkDU,UAAlD,CAtCHN,CAAAA,CApF+F,CA0H9F;EAGD,MAAMkD,aAAa,GAAG,kBAAA,CACnBtC,KAAD,IAAgC;IAC9B,IAAI,CAACpB,IAAD,IAAS,CAACC,OAAd,EAAA;IACA,IAAIa,UAAU,CAACC,MAAf,EAAA;IAEA,MAAM4C,QAAQ,GAAGvC,KAAK,CAACwC,GAANxC,KAAc,KAAdA,IAAuB,CAACA,KAAK,CAACyC,MAA9BzC,IAAwC,CAACA,KAAK,CAAC0C,OAA/C1C,IAA0D,CAACA,KAAK,CAAC2C,OAAlF;IACA,MAAMnC,cAAc,GAAGC,QAAQ,CAACC,aAAhC;IAEA,IAAI6B,QAAQ,IAAI/B,cAAhB,EAAgC;MAC9B,MAAMtB,SAAS,GAAGc,KAAK,CAAC4C,aAAxB;MACA,MAAM,CAACC,KAAD,EAAQC,IAAR,CAAA,GAAgBC,sCAAgB,CAAC7D,SAAD,CAAtC;MACA,MAAM8D,yBAAyB,GAAGH,KAAK,IAAIC,IAA3C,CAAA,CAAA;MAGA,IAAI,CAACE,yBAAL,EACE;QAAA,IAAIxC,cAAc,KAAKtB,SAAvB,EAAkCc,KAAK,CAACiD,cAANjD,CAAAA,CAAlC;OAAA,MACK;QACL,IAAI,CAACA,KAAK,CAACkD,QAAP,IAAmB1C,cAAc,KAAKsC,IAA1C,EAAgD;UAC9C9C,KAAK,CAACiD,cAANjD,CAAAA,CAAAA;UACA,IAAIpB,IAAJ,EAAU,2BAAK,CAACiE,KAAD,EAAQ;YAAE1C,MAAM,EAANA;WAAV,CAAL;SAFZ,MAGO,IAAIH,KAAK,CAACkD,QAANlD,IAAkBQ,cAAc,KAAKqC,KAAzC,EAAgD;UACrD7C,KAAK,CAACiD,cAANjD,CAAAA,CAAAA;UACA,IAAIpB,IAAJ,EAAU,2BAAK,CAACkE,IAAD,EAAO;YAAE3C,MAAM,EAANA;WAAT,CAAL;QACX;MACF;IACF;GAzBiB,EA2BpB,CAACvB,IAAD,EAAOC,OAAP,EAAgBa,UAAU,CAACC,MAA3B,CA3BoB,CA0BnB;EAIH,OAAA,aACE,oBAAA,CAAC,gBAAD,CAAW,GAAX,EADF,oCAAA,CAAA;IACiB,QAAQ,EAAE,CAAV;GAAf,EAAiCwD,UAAjC,EAAA;IAA6C,GAAG,EAAE5D,YAAlD;IAAgE,SAAS,EAAT;GAAhE,CAAA,CADF;CA3JiB,CA8JlB;AAED;AAAA,MAAA,CAAA,MAAA,CAAA,yCAAA,EAAA;EAAA,WAAA,EAAA;CAAA,CAAA;AAEA;;AAEA,oGAFA,CAIA;;;AAGA;AACA,SAASyC,gCAAT,CAAoBoB,UAApB,EAAwE;EAAA,IAAzB;IAAEjD,MAAM,GAANA;EAAAA,CAAF,GAAA,SAAA,CAAA,MAAA,QAAA,SAAA,QAAA,SAAA,GAAA,SAAA,MAAqB,CAAA,CAApE;EACE,MAAMuB,wBAAwB,GAAGjB,QAAQ,CAACC,aAA1C;EACA,KAAK,MAAM2C,SAAX,IAAwBD,UAAxB,EAAoC;IAClCrC,2BAAK,CAACsC,SAAD,EAAY;cAAElD;KAAd,CAALY;IACA,IAAIN,QAAQ,CAACC,aAATD,KAA2BiB,wBAA/B,EAAA;EACD;AACF;AAED;;AAEA;AACA,SAASqB,sCAAT,CAA0B7D,SAA1B,EAAkD;EAChD,MAAMkE,UAAU,GAAGlB,2CAAqB,CAAChD,SAAD,CAAxC;EACA,MAAM2D,KAAK,GAAGS,iCAAW,CAACF,UAAD,EAAalE,SAAb,CAAzB;EACA,MAAM4D,IAAI,GAAGQ,iCAAW,CAACF,UAAU,CAACG,OAAXH,CAAAA,CAAD,EAAuBlE,SAAvB,CAAxB;EACA,OAAO,CAAC2D,KAAD,EAAQC,IAAR,CAAP;AACD;AAED;;;;;;;;;AASA;AACA,SAASZ,2CAAT,CAA+BhD,SAA/B,EAAuD;EACrD,MAAMsE,KAAoB,GAAG,EAA7B;EACA,MAAMC,MAAM,GAAG,QAAQ,CAACC,gBAAT,CAA0BxE,SAA1B,EAAqCyE,UAAU,CAACC,YAAhD,EAA8D;IAC3EC,UAAU,EAAGpE,IAAD,IAAe;MACzB,MAAMqE,aAAa,GAAGrE,IAAI,CAACsE,OAALtE,KAAiB,OAAjBA,IAA4BA,IAAI,CAACuE,IAALvE,KAAc,QAAhE;MACA,IAAIA,IAAI,CAACwE,QAALxE,IAAiBA,IAAI,CAACyE,MAAtBzE,IAAgCqE,aAApC,EAAmD,OAAOH,UAAU,CAACQ,WAAlB,CAF1B,CAEzB;MAEA;MACA;MACA,OAAO1E,IAAI,CAAC2E,QAAL3E,IAAiB,CAAjBA,GAAqBkE,UAAU,CAACU,aAAhC5E,GAAgDkE,UAAU,CAACQ,WAAlE;IACD;GARY,CAA8D;EAU7E,OAAOV,MAAM,CAACa,QAAPb,CAAAA,CAAP,EAA0BD,KAAK,CAACe,IAANf,CAAWC,MAAM,CAACe,WAAlBhB,CAAAA,CAZ2B,CAYrD;EAEA;EACA,OAAOA,KAAP;AACD;AAED;;;AAGA;AACA,SAASF,iCAAT,CAAqBmB,QAArB,EAA8CvF,SAA9C,EAAsE;EACpE,KAAK,MAAMwF,OAAX,IAAsBD,QAAtB,EAAgC;IAC9B;IACA,IAAI,CAACE,8BAAQ,CAACD,OAAD,EAAU;MAAEE,IAAI,EAAJA;KAAZ,CAAb,EAA6C,OAAOF,OAA7B;EACxB;AACF;AAED,SAASC,8BAAT,CAAkBlF,IAAlB,EAAA,IAAA,EAAuE;EAAA,IAAlC;UAAEmF;EAAAA,CAAvC,GAAA,IAAA;EACE,IAAIC,gBAAgB,CAACpF,IAAD,CAAhBoF,CAAuBC,UAAvBD,KAAsC,QAA1C,EAAoD,OAAO,IAA3D;EACA,OAAOpF,IAAP,EAAa;IACX;IACA,IAAImF,IAAI,KAAKG,SAATH,IAAsBnF,IAAI,KAAKmF,IAAnC,EAAyC,OAAO,KAAhD;IACA,IAAIC,gBAAgB,CAACpF,IAAD,CAAhBoF,CAAuBG,OAAvBH,KAAmC,MAAvC,EAA+C,OAAO,IAAtD;IACApF,IAAI,GAAGA,IAAI,CAACwF,aAAZxF;EACD;EACD,OAAO,KAAP;AACD;AAED,SAASyF,uCAAT,CAA2BR,OAA3B,EAA8F;EAC5F,OAAOA,OAAO,YAAYS,gBAAnBT,IAAuC,QAAA,IAAYA,OAA1D;AACD;AAED,SAAS3D,2BAAT,CAAe2D,OAAf,EAA0E;EAAA,IAAzB;IAAEvE,MAAM,GAANA;EAAAA,CAAF,GAAA,SAAA,CAAA,MAAA,QAAA,SAAA,QAAA,SAAA,GAAA,SAAA,MAAqB,CAAA,CAAtE;EACE;EACA,IAAIuE,OAAO,IAAIA,OAAO,CAAC3D,KAAvB,EAA8B;IAC5B,MAAMW,wBAAwB,GAAGjB,QAAQ,CAACC,aAA1C,CAAA,CAAA;IAEAgE,OAAO,CAAC3D,KAAR2D,CAAc;MAAEU,aAAa,EAAbA;KAAhBV,CAAAA,CAH4B,CAGd;IAEd,IAAIA,OAAO,KAAKhD,wBAAZgD,IAAwCQ,uCAAiB,CAACR,OAAD,CAAzDA,IAAsEvE,MAA1E,EACEuE,OAAO,CAACvE,MAARuE,CAAAA,CADF;EAED;AACF;AAED;;AAEA;AAGA,MAAMlD,sCAAgB,GAAG6D,4CAAsB,CAAA,CAA/C;AAEA,SAASA,4CAAT,CAAA,EAAkC;EAChC,8DACA,IAAIC,KAAsB,GAAG,EAA7B;EAEA,OAAO;IACL7D,GAAG,CAAC/B,UAAD,EAA4B;MAC7B;MACA,MAAM6F,gBAAgB,GAAGD,KAAK,CAAC,CAAD,CAA9B;MACA,IAAI5F,UAAU,KAAK6F,gBAAnB,EACEA,gBAAgB,KAAA,IAAhBA,IAAAA,gBAAgB,KAAA,KAAA,CAAhBA,IAAAA,gBAAgB,CAAE3F,KAAlB2F,CAAAA,CAAAA;MACD;MAEDD,KAAK,GAAGE,iCAAW,CAACF,KAAD,EAAQ5F,UAAR,CAAnB4F;MACAA,KAAK,CAACG,OAANH,CAAc5F,UAAd4F,CAAAA;KATG;IAYLjD,MAAM,CAAC3C,UAAD,EAA4B;MAAA,IAAA,OAAA;MAChC4F,KAAK,GAAGE,iCAAW,CAACF,KAAD,EAAQ5F,UAAR,CAAnB4F;MACA,CAAA,OAAA,GAAA,KAAK,CAAC,CAAD,CAAL,MAAA,IAAA,IAAA,OAAA,KAAA,KAAA,CAAA,IAAA,OAAA,CAAUzF,MAAV,CAAA,CAAA;IACD;GAfH;AAiBD;AAED,SAAS2F,iCAAT,CAAwBE,KAAxB,EAAoCC,IAApC,EAA6C;EAC3C,MAAMC,YAAY,GAAG,C,GAAIF,KAAJ,CAArB;EACA,MAAMG,KAAK,GAAGD,YAAY,CAACE,OAAbF,CAAqBD,IAArBC,CAAd;EACA,IAAIC,KAAK,KAAK,CAAA,CAAd,EACED,YAAY,CAACG,MAAbH,CAAoBC,KAApBD,EAA2B,CAA3BA,CAAAA;EAEF,OAAOA,YAAP;AACD;AAED,SAAS3D,iCAAT,CAAqB+D,KAArB,EAA2C;EACzC,OAAO,KAAK,CAACC,MAAN,CAAcN,IAAD,IAAUA,IAAI,CAAC5B,OAAL4B,KAAvB,GAAA,CAAP;AACD;AAED,MAAMO,yCAAI,GAAGzH,yCAAb","sourcesContent":["import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\n\nimport type * as Radix from '@radix-ui/react-primitive';\n\nconst AUTOFOCUS_ON_MOUNT = 'focusScope.autoFocusOnMount';\nconst AUTOFOCUS_ON_UNMOUNT = 'focusScope.autoFocusOnUnmount';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\ntype FocusableTarget = HTMLElement | { focus(): void };\n\n/* -------------------------------------------------------------------------------------------------\n * FocusScope\n * -----------------------------------------------------------------------------------------------*/\n\nconst FOCUS_SCOPE_NAME = 'FocusScope';\n\ntype FocusScopeElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface FocusScopeProps extends PrimitiveDivProps {\n  /**\n   * When `true`, tabbing from last item will focus first tabbable\n   * and shift+tab from first item will focus last tababble.\n   * @defaultValue false\n   */\n  loop?: boolean;\n\n  /**\n   * When `true`, focus cannot escape the focus scope via keyboard,\n   * pointer, or a programmatic focus.\n   * @defaultValue false\n   */\n  trapped?: boolean;\n\n  /**\n   * Event handler called when auto-focusing on mount.\n   * Can be prevented.\n   */\n  onMountAutoFocus?: (event: Event) => void;\n\n  /**\n   * Event handler called when auto-focusing on unmount.\n   * Can be prevented.\n   */\n  onUnmountAutoFocus?: (event: Event) => void;\n}\n\nconst FocusScope = React.forwardRef<FocusScopeElement, FocusScopeProps>((props, forwardedRef) => {\n  const {\n    loop = false,\n    trapped = false,\n    onMountAutoFocus: onMountAutoFocusProp,\n    onUnmountAutoFocus: onUnmountAutoFocusProp,\n    ...scopeProps\n  } = props;\n  const [container, setContainer] = React.useState<HTMLElement | null>(null);\n  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);\n  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);\n  const lastFocusedElementRef = React.useRef<HTMLElement | null>(null);\n  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));\n\n  const focusScope = React.useRef({\n    paused: false,\n    pause() {\n      this.paused = true;\n    },\n    resume() {\n      this.paused = false;\n    },\n  }).current;\n\n  // Takes care of trapping focus if focus is moved outside programmatically for example\n  React.useEffect(() => {\n    if (trapped) {\n      function handleFocusIn(event: FocusEvent) {\n        if (focusScope.paused || !container) return;\n        const target = event.target as HTMLElement | null;\n        if (container.contains(target)) {\n          lastFocusedElementRef.current = target;\n        } else {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n\n      function handleFocusOut(event: FocusEvent) {\n        if (focusScope.paused || !container) return;\n        const relatedTarget = event.relatedTarget as HTMLElement | null;\n\n        // A `focusout` event with a `null` `relatedTarget` will happen in at least two cases:\n        //\n        // 1. When the user switches app/tabs/windows/the browser itself loses focus.\n        // 2. In Google Chrome, when the focused element is removed from the DOM.\n        //\n        // We let the browser do its thing here because:\n        //\n        // 1. The browser already keeps a memory of what's focused for when the page gets refocused.\n        // 2. In Google Chrome, if we try to focus the deleted focused element (as per below), it\n        //    throws the CPU to 100%, so we avoid doing anything for this reason here too.\n        if (relatedTarget === null) return;\n\n        // If the focus has moved to an actual legitimate element (`relatedTarget !== null`)\n        // that is outside the container, we move focus to the last valid focused element inside.\n        if (!container.contains(relatedTarget)) {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n\n      // When the focused element gets removed from the DOM, browsers move focus\n      // back to the document.body. In this case, we move focus to the container\n      // to keep focus trapped correctly.\n      function handleMutations(mutations: MutationRecord[]) {\n        const focusedElement = document.activeElement as HTMLElement | null;\n        if (focusedElement !== document.body) return;\n        for (const mutation of mutations) {\n          if (mutation.removedNodes.length > 0) focus(container);\n        }\n      }\n\n      document.addEventListener('focusin', handleFocusIn);\n      document.addEventListener('focusout', handleFocusOut);\n      const mutationObserver = new MutationObserver(handleMutations);\n      if (container) mutationObserver.observe(container, { childList: true, subtree: true });\n\n      return () => {\n        document.removeEventListener('focusin', handleFocusIn);\n        document.removeEventListener('focusout', handleFocusOut);\n        mutationObserver.disconnect();\n      };\n    }\n  }, [trapped, container, focusScope.paused]);\n\n  React.useEffect(() => {\n    if (container) {\n      focusScopesStack.add(focusScope);\n      const previouslyFocusedElement = document.activeElement as HTMLElement | null;\n      const hasFocusedCandidate = container.contains(previouslyFocusedElement);\n\n      if (!hasFocusedCandidate) {\n        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);\n        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container.dispatchEvent(mountEvent);\n        if (!mountEvent.defaultPrevented) {\n          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });\n          if (document.activeElement === previouslyFocusedElement) {\n            focus(container);\n          }\n        }\n      }\n\n      return () => {\n        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n\n        // We hit a react bug (fixed in v17) with focusing in unmount.\n        // We need to delay the focus a little to get around it for now.\n        // See: https://github.com/facebook/react/issues/17894\n        setTimeout(() => {\n          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);\n          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          container.dispatchEvent(unmountEvent);\n          if (!unmountEvent.defaultPrevented) {\n            focus(previouslyFocusedElement ?? document.body, { select: true });\n          }\n          // we need to remove the listener after we `dispatchEvent`\n          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n\n          focusScopesStack.remove(focusScope);\n        }, 0);\n      };\n    }\n  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);\n\n  // Takes care of looping focus (when tabbing whilst at the edges)\n  const handleKeyDown = React.useCallback(\n    (event: React.KeyboardEvent) => {\n      if (!loop && !trapped) return;\n      if (focusScope.paused) return;\n\n      const isTabKey = event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey;\n      const focusedElement = document.activeElement as HTMLElement | null;\n\n      if (isTabKey && focusedElement) {\n        const container = event.currentTarget as HTMLElement;\n        const [first, last] = getTabbableEdges(container);\n        const hasTabbableElementsInside = first && last;\n\n        // we can only wrap focus if we have tabbable edges\n        if (!hasTabbableElementsInside) {\n          if (focusedElement === container) event.preventDefault();\n        } else {\n          if (!event.shiftKey && focusedElement === last) {\n            event.preventDefault();\n            if (loop) focus(first, { select: true });\n          } else if (event.shiftKey && focusedElement === first) {\n            event.preventDefault();\n            if (loop) focus(last, { select: true });\n          }\n        }\n      }\n    },\n    [loop, trapped, focusScope.paused]\n  );\n\n  return (\n    <Primitive.div tabIndex={-1} {...scopeProps} ref={composedRefs} onKeyDown={handleKeyDown} />\n  );\n});\n\nFocusScope.displayName = FOCUS_SCOPE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * Attempts focusing the first element in a list of candidates.\n * Stops when focus has actually moved.\n */\nfunction focusFirst(candidates: HTMLElement[], { select = false } = {}) {\n  const previouslyFocusedElement = document.activeElement;\n  for (const candidate of candidates) {\n    focus(candidate, { select });\n    if (document.activeElement !== previouslyFocusedElement) return;\n  }\n}\n\n/**\n * Returns the first and last tabbable elements inside a container.\n */\nfunction getTabbableEdges(container: HTMLElement) {\n  const candidates = getTabbableCandidates(container);\n  const first = findVisible(candidates, container);\n  const last = findVisible(candidates.reverse(), container);\n  return [first, last] as const;\n}\n\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction getTabbableCandidates(container: HTMLElement) {\n  const nodes: HTMLElement[] = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    },\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement);\n  // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n\n/**\n * Returns the first visible element in a list.\n * NOTE: Only checks visibility up to the `container`.\n */\nfunction findVisible(elements: HTMLElement[], container: HTMLElement) {\n  for (const element of elements) {\n    // we stop checking if it's hidden at the `container` level (excluding)\n    if (!isHidden(element, { upTo: container })) return element;\n  }\n}\n\nfunction isHidden(node: HTMLElement, { upTo }: { upTo?: HTMLElement }) {\n  if (getComputedStyle(node).visibility === 'hidden') return true;\n  while (node) {\n    // we stop at `upTo` (excluding it)\n    if (upTo !== undefined && node === upTo) return false;\n    if (getComputedStyle(node).display === 'none') return true;\n    node = node.parentElement as HTMLElement;\n  }\n  return false;\n}\n\nfunction isSelectableInput(element: any): element is FocusableTarget & { select: () => void } {\n  return element instanceof HTMLInputElement && 'select' in element;\n}\n\nfunction focus(element?: FocusableTarget | null, { select = false } = {}) {\n  // only focus if that element is focusable\n  if (element && element.focus) {\n    const previouslyFocusedElement = document.activeElement;\n    // NOTE: we prevent scrolling on focus, to minimize jarring transitions for users\n    element.focus({ preventScroll: true });\n    // only select if its not the same element, it supports selection and we need to select\n    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)\n      element.select();\n  }\n}\n\n/* -------------------------------------------------------------------------------------------------\n * FocusScope stack\n * -----------------------------------------------------------------------------------------------*/\n\ntype FocusScopeAPI = { paused: boolean; pause(): void; resume(): void };\nconst focusScopesStack = createFocusScopesStack();\n\nfunction createFocusScopesStack() {\n  /** A stack of focus scopes, with the active one at the top */\n  let stack: FocusScopeAPI[] = [];\n\n  return {\n    add(focusScope: FocusScopeAPI) {\n      // pause the currently active focus scope (at the top of the stack)\n      const activeFocusScope = stack[0];\n      if (focusScope !== activeFocusScope) {\n        activeFocusScope?.pause();\n      }\n      // remove in case it already exists (because we'll re-add it at the top of the stack)\n      stack = arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n\n    remove(focusScope: FocusScopeAPI) {\n      stack = arrayRemove(stack, focusScope);\n      stack[0]?.resume();\n    },\n  };\n}\n\nfunction arrayRemove<T>(array: T[], item: T) {\n  const updatedArray = [...array];\n  const index = updatedArray.indexOf(item);\n  if (index !== -1) {\n    updatedArray.splice(index, 1);\n  }\n  return updatedArray;\n}\n\nfunction removeLinks(items: HTMLElement[]) {\n  return items.filter((item) => item.tagName !== 'A');\n}\n\nconst Root = FocusScope;\n\nexport {\n  FocusScope,\n  //\n  Root,\n};\nexport type { FocusScopeProps };\n"]},"metadata":{},"sourceType":"module"}